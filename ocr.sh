#!/usr/bin/env bash


# Configure script behavior (https://stackoverflow.com/a/2871034/6651650).
# -e script exits on error 
# -u errors on undefined variables 
# -o pipefail exits on command pipe failures. 
set -euo pipefail
# -x prints commands before execution 
set -x

# ⋘──────── Set script options ────────⋙
# TODO: Make these command line options.
in_file_name_base=Revisions_11-12
out_file_name_base=Revisions_11-12

# ⋘──────── Construct paths ────────⋙
input_file_path="in_dir/$in_file_name_base.pdf"
output_directory="out_dir/$out_file_name_base"
output_pdfs_directory="$output_directory/student-pdfs"
output_page_lists_directory="$output_directory/student_page_lists"

# ╭───────────────────────────────────────────╮
# │             Setup directories             │
# ╰───────────────────────────────────────────╯
# ⋘──────── Create output directory for given PDF  ────────⋙

# Remove the student_page_lists folder if it exists. Otherwise, send the error message to /dev/null and ignore the error using "|| true".
# https://superuser.com/a/435951/734378
rm $output_directory -r 2> /dev/null || true

mkdir $output_directory -p
mkdir $output_pdfs_directory -p
mkdir $output_page_lists_directory -p


# ╭───────────────────────────────────────────────────────╮
# │             Convert from PDF to an image.             │
# ╰───────────────────────────────────────────────────────╯
# Set the output resolution using "-density."
# name_x_offset=100 # pixels
# name_y_offset=1950 # pixels
# name_width=600 # pixels
# name_height=100 # pixels
# convert -density 188 -crop "${name_width}x${name_height}+$name_x_offset+$name_y_offset" $in_file_name_base.pdf  $in_file_name_base/page-%d.jpg 

# At density=188, the height of the page is ~2070 pixels.
pdf_rasterization_density=188
name_x_offset=0 # pixels
name_width=600 # pixels

# Lower corner
name_y_offset=1900 # pixels
name_height=1000 # pixels (make it overly tall. convert will crop to the page.)

# Upper corner (old)
# name_y_offset=200 # pixels
# name_height=300 # pixels (make it overly tall. convert will crop to the page.)

convert_batch_size=10
total_pages=$(pdftk "$input_file_path" dump_data | grep NumberOfPages | awk '{print $2}')

# ! For testing, only do first few pages.
# convert_batch_size=2
# total_pages=6

# ╭────────────────────────────────────────────────────────╮
# │  ╭──────────────────────────────────────────────────╮  │
# │  │             Perform OCR on each page             │  │
# │  ╰──────────────────────────────────────────────────╯  │
# ╰────────────────────────────────────────────────────────╯
for batch in $(seq 0 $(( (total_pages + convert_batch_size - 1) / convert_batch_size - 1 ))); do
    start_page=$((batch * convert_batch_size))
    end_page=$((start_page + convert_batch_size - 1))
    
    if [ $end_page -ge $total_pages ]; then
        end_page=$((total_pages - 1))
    fi
    
    echo "Processing pages ${start_page} to ${end_page}..."
    
    # Use ImageMagick's bracket notation to select page ranges.
    convert -density $pdf_rasterization_density \
            -crop "${name_width}x${name_height}+${name_x_offset}+${name_y_offset}" \
            "${input_file_path}[${start_page}-${end_page}]" \
            "${output_directory}/page-%d.jpg"

  # ╭───────────────────────────────────────────────╮
  # │             Use OCR to Find Names             │
  # ╰───────────────────────────────────────────────╯
  i=$start_page
  while [[ -e  $output_directory/page-$i.jpg ]]; # If file exists.
  do 
    # ⋘──────── Run tesseract OCR ────────⋙
    tesseract_in_file=$output_directory/page-$i.jpg
    tesseract_out_file=$output_directory/page-$i 
    tesseract_config_file=tesseract_config
    student_names_file=student_names.user-words
    tesseract $tesseract_in_file $tesseract_out_file $tesseract_config_file

    # ╭────────────────────────────────────────────────────────────────────────╮
    # │             Use regular expression to match "Name: [NAME]"             │
    # ╰────────────────────────────────────────────────────────────────────────╯
    # Read the text generated by tesseract 
    # student=$(cat $in_file_name_base/page-$i.txt)
    # Read the text from page i, using regex to find "Name: <name of the student>". 
    # Regex101.com Link:
    # https://regex101.com/r/tniHLV/1
    # The format of this regular expression is 
    # * "^.*": Anything preceding "Name:"
    # * "[^a-zA-Z]+": White space and other characters, not including letters. Includes the colon after "Name: ". Sometimes the OCR also generates "_" due to the underlining.
    # * "\w+([ ]+\w+)*)": The student's name
    student=$(cat $output_directory/page-$i.txt | sed -Ez 's/^.*Name[^a-zA-Z]+([a-zA-Z.]+([ ]+\w+)*).*$/\1/')

    if [[ -z $student ]]; then
      echo "Student name was not found on page $i."
      exit 1
    fi

    # Write the current page number to the student's list of pages
    # We add +1 to the index so that it is one-indexed instead of zero-indexed, which makes it easier to use as page numbers for pdftk.
    echo $(($i + 1)) >> "$output_page_lists_directory/$student.txt"

    # Increment counter
    i=$(($i + 1))
  done
done



# ╭─────────────────────────────────────────────────────────────────────╮
# │             Use the PDF Toolkit (pdftk) to Select Pages             │
# ╰─────────────────────────────────────────────────────────────────────╯
for filename in $output_page_lists_directory/*; do 
  # Use "basename" to get the student name without the extension (".txt")
  student=$(basename "$filename" .txt)

  # Read the list of pages for the student.
  student_pages=$(cat "$filename") 

  # Use pdftk to extract the student's pages.
  pdftk $input_file_path cat $student_pages output "$output_pdfs_directory/${out_file_name_base} $student.pdf"
done

